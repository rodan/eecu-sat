
// program that converts a number of raw analog capture files generated by saleae's logic into a srzip file recognized by sigrok

#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <getopt.h>
#include <dirent.h>
#include <fnmatch.h>
#include <libgen.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "config.h"
#include "tlpi_hdr.h"
#include "proj.h"
#include "version.h"
#include "list.h"
#include "output.h"
#include "output_analog.h"
#include "output_srzip.h"
#include "transform.h"
#include "calib.h"
#include "parsers.h"
#include "session.h"

// program arguments
static char *opt_default_input_prefix = "analog_[0-9]*.bin";
struct cmdline_opt opt = { 0 };
LIST(channels);

// 00000000  3c 53 41 4c 45 41 45 3e  00 00 00 00 01 00 00 00  |<SALEAE>........|
static const char saleae_magic[8] = {0x3c, 0x53, 0x41, 0x4c, 0x45, 0x41, 0x45, 0x3e};
#define SALEAE_HEADER_SZ 0x30

static void show_usage(void)
{
    fprintf(stdout, "Usage: eecu-sat [-i PREFIX] [-o FILE]\n");
    fprintf(stdout, "\t-i, --input\n");
    fprintf(stdout, "\t\ta prefix that defines the input raw analog files. default is %s\n", opt_default_input_prefix);
    fprintf(stdout, "\t-o, --output=FILE\n");
    fprintf(stdout, "\t\toutput file to be generated\n");
    fprintf(stdout, "\t-O, --output-format OUTPUT\n");
    fprintf(stdout, "\t\toutput data format to use, see -L for list\n");
    fprintf(stdout, "\t-s, --skip\n");
    fprintf(stdout, "\t\tskips the first 0x30 bytes (saleae header)\n");
    fprintf(stdout, "\t-T, --transform-module TRANSFORM\n");
    fprintf(stdout, "\t\tprocess data via a function, see -L for list\n");
    fprintf(stdout, "\t--initcal\n");
    fprintf(stdout, "\t-L, --list\n");
    fprintf(stdout, "\t\tlist known output formats and transform modules\n");
    fprintf(stdout, "\t-h, --help\n");
    fprintf(stdout, "\t-v, --version\n");
}

static void show_version(void)
{
    fprintf(stdout, "eecu-sat version: %d.%d build %d commit %d\n", VER_MAJOR, VER_MINOR, BUILD, COMMIT);
}

static void show_capabilities(void)
{
    const struct sat_output_module **outputs;
    const struct sat_transform_module **transforms;
    int i;

    printf("Supported output formats:\n");
    outputs = sat_output_list();
    for (i = 0; outputs[i]; i++) {
        printf("  %-20s %s\n", sat_output_id_get(outputs[i]), sat_output_description_get(outputs[i]));
    }

    printf("Supported transform modules:\n");
    transforms = sat_transform_list();
    for (i = 0; transforms[i]; i++) {
        printf("  %-20s %s\n", sat_transform_id_get(transforms[i]), sat_transform_description_get(transforms[i]));
    }

}

static int parse_options(int argc, char **argv)
{
    int q, opt_idx;

    while (1) {
        opt_idx = 0;
        static struct option long_options[] = {
            {"input", 1, 0, 'i'},
            {"output", 1, 0, 'o'},
            {"output-format", 1, 0, 'O'},
            {"transform-module", 1, 0, 'T'},
            {"skip", 0, 0, 's'},
            {"initcal", 0, 0, 'x'},
            {"list", 0, 0, 'L'},
            {"help", 0, 0, 'h'},
            {"version", 0, 0, 'v'},
            {0, 0, 0, 0}
        };

        q = getopt_long(argc, argv, "i:o:O:T:xhLv", long_options, &opt_idx);
        if (q == -1) {
            break;
        }
        switch (q) {
        case 'i':
            opt.input_prefix = optarg;
            break;
        case 'o':
            opt.output_file = optarg;
            break;
        case 'O':
            opt.output_format = optarg;
            break;
        case 'T':
            opt.transform_module = optarg;
            break;
        case 'x':
            opt.action |= ACTION_DO_CALIB_INIT;
            opt.action &= ~ACTION_DO_CONVERT;
            break;
        case 's':
            opt.skip_header = true;
            break;
        case 'L':
            show_capabilities();
            break;
        case 'h':
            show_usage();
            break;
        case 'v':
            show_version();
            break;
        default:
            break;
        }
    }

    if (!opt.input_prefix) {
        opt.input_prefix = opt_default_input_prefix;
    }

    return EXIT_SUCCESS;
}

bool saleae_magic_is_present(uint8_t *data)
{
    if (memcmp(data, saleae_magic, 8) == 0)
        return true;
    return false;
}

#ifdef CONFIG_DEBUG
void ll_print(ch_data_t *head)
{
    ch_data_t *p = head;

    if (head == NULL) {
        printf("ll is empty\n");
        return;
    }

    while (NULL != p) {
        printf("n %p, [%s] sz %ld  next %p\n", (void *)p, p->input_file_name, p->input_file_size, (void *)p->next);
        if (p->next != NULL) {
            p = p->next;
        } else {
            return;
        }
    }
}
#endif

static void ll_free_all(ch_data_t **head)
{
    if (*head == NULL)
        return;
    ch_data_t *p = *head;
    ch_data_t *del;

    while (NULL != p) {
        //printf("remove node @%p\n", (void *)p);
        del = p;
        if (del->input_file_name)
            free(del->input_file_name);
        if (del->output_file_name)
            free(del->output_file_name);
        p = p->next;
        free(del);
    }

    *head = NULL;
}

static int run_session(const struct sr_dev_inst *sdi)
{
    int ret = EXIT_SUCCESS;
    struct sat_output *o = NULL;
    struct sat_transform *t = NULL;
    ch_data_t *ch_data_ptr;
    ssize_t read_len;
    int i, j;
    int fd;
    struct sr_datafeed_packet pkt = { 0 };
    struct sr_datafeed_packet *tpkt;
    struct sr_datafeed_analog analog = { 0 };
    struct sr_analog_encoding encoding = { 0 };
	struct sr_analog_meaning meaning = { 0 };
	struct sr_analog_spec spec = { 0 };
    struct sat_generic_pkt gpkt = { 0 };
    bool transform_initialized = 0;

    analog.encoding = &encoding;
    analog.meaning = &meaning;
    analog.spec = &spec;

    if (!opt.output_format) {
        fprintf(stderr, "output format not selected\n");
        return EXIT_FAILURE;
    }

    if (opt.output_file) {
        if (!(o = setup_output_format(sdi, opt.output_file, opt.output_format))) {
            fprintf(stderr, "Failed to initialize transform module.\n");
            return EXIT_FAILURE;
        }
    } else {
        fprintf(stderr, "output file not defined, exiting.\n");
        return EXIT_FAILURE;
    }

    if (opt.transform_module) {
        if (!(t = setup_transform_module(sdi, opt.transform_module))) {
            fprintf(stderr, "Failed to initialize transform module.\n");
            return EXIT_FAILURE;
        }
        transform_initialized = 1;
    }

    analog.data = (uint8_t *) calloc(CHUNK_SIZE, 1);
    if (!analog.data) {
        errMsg("during calloc");
        ret = EXIT_FAILURE;
        goto cleanup;
    }

    gpkt.payload = (uint8_t *) calloc(CHUNK_SIZE, 1);
    if (!gpkt.payload) {
        errMsg("during calloc");
        ret = EXIT_FAILURE;
        goto cleanup;
    }

    ch_data_ptr = list_head(channels);
    i = 0;
    pkt.payload = &analog;

    while (NULL != ch_data_ptr) {
        i++;

        if ((fd = open(ch_data_ptr->input_file_name, O_RDONLY)) < 0) {
            errMsg("opening input file");
            ret = EXIT_FAILURE;
            goto cleanup;
        }

        // skip saleae header if present
        if (read(fd, analog.data, 8) != 8) {
            errMsg("during read()");
            close(fd);
            ret = EXIT_FAILURE;
            goto cleanup;
        }
        if (saleae_magic_is_present(analog.data)) {
            if (lseek(fd, SALEAE_HEADER_SZ, SEEK_SET) < 0) {
                errMsg("during lseek()");
                close(fd);
                ret = EXIT_FAILURE;
                goto cleanup;
            }
        } else {
            if (lseek(fd, 0x0, SEEK_SET) < 0) {
                errMsg("during lseek()");
                close(fd);
                ret = EXIT_FAILURE;
                goto cleanup;
            }
        }

        j = 1;
        while ((read_len = read(fd, analog.data, CHUNK_SIZE)) > 0) {
            o->ch = i;
            o->chunk = j;
            if (transform_initialized) {
                t->ch = i;
                t->chunk = j;
            }
            if (j == 1) {
                pkt.type = SR_DF_FRAME_BEGIN;
                if (transform_initialized)
                    t->module->receive(t, &pkt, &tpkt);
                o->module->receive(o, &pkt);
            }
            pkt.type = SR_DF_ANALOG;
            analog.num_samples = read_len / sizeof(float);
            if (transform_initialized) {
                t->module->receive(t, &pkt, &tpkt);
                o->module->receive(o, tpkt);
            } else {
                o->module->receive(o, &pkt);
            }
            j++;
        }
        close(fd);

        pkt.type = SR_DF_FRAME_END;
        if (transform_initialized) {
            t->module->receive(t, &pkt, &tpkt);
        }
        o->module->receive(o, &pkt);

        if (ch_data_ptr->next != NULL) {
            ch_data_ptr = ch_data_ptr->next;
        } else {
            break;
        }
    }

    //printf("%d channels exported\n", i);

 cleanup:
    if (o)
        sat_output_free(o);
    if (t)
        sat_transform_free(t);
    if (analog.data)
        free(analog.data);
    if (gpkt.payload)
        free(gpkt.payload);

    return ret;
}

int main(int argc, char **argv)
{
    int res;
    struct dirent **namelist;
    int i, ch_cnt;
    int channel_total = 0;
    char *_input_dirname;
    char *input_dirname;
    char *_input_basename;
    char *input_basename;
    ssize_t file_name_len;
    FILE *fp;
    ch_data_t *ch_data_ptr;
    ssize_t file_size_compare = -1;
    int ret = EXIT_SUCCESS;
    struct sr_dev_inst sdi;

    if (parse_options(argc, argv)) {
        return EXIT_FAILURE;
    }

    _input_dirname = strdup(opt.input_prefix);
    _input_basename = strdup(opt.input_prefix);

    input_dirname = dirname(_input_dirname);
    input_basename = basename(_input_basename);

    //printf("input files prefix is %s, dirname %s, basename %s\n", opt_input_prefix, input_dirname, input_basename);
    ch_cnt = scandir(input_dirname, &namelist, NULL, versionsort);
    list_init(channels);

    // create a linked list with all files that match the filter defined by the --input option
    if (ch_cnt < 0)
        perror("scandir");
    else {
        for (i = 0; i < ch_cnt; i++) {
            res = fnmatch(input_basename, namelist[i]->d_name, FNM_EXTMATCH);
            if (!res) {
                //printf("%s matches\n", namelist[i]->d_name);
                channel_total++;
                ch_data_ptr = calloc(1, sizeof(struct ch_data));
                if (!ch_data_ptr) {
                    errMsg("during calloc");
                    ret = EXIT_FAILURE;
                    goto cleanup;
                }

                file_name_len = strlen(input_dirname) + strlen(namelist[i]->d_name);
                ch_data_ptr->input_file_name = (char *)calloc(file_name_len + 3, sizeof(char));
                if (!ch_data_ptr->input_file_name) {
                    errMsg("during calloc");
                    ret = EXIT_FAILURE;
                    goto cleanup;
                }
                snprintf(ch_data_ptr->input_file_name, file_name_len + 2, "%s/%s", input_dirname, namelist[i]->d_name);

                if (opt.output_file && (opt.action & ACTION_DO_CALIBRATION)) {
                    file_name_len = strlen(opt.output_file) + strlen(namelist[i]->d_name);
                    ch_data_ptr->output_file_name = (char *)calloc(file_name_len + 3, sizeof(char));
                    if (!ch_data_ptr->output_file_name) {
                        errMsg("during calloc");
                        ret = EXIT_FAILURE;
                        goto cleanup;
                    }
                    snprintf(ch_data_ptr->output_file_name, file_name_len + 2, "%s/%s", opt.output_file,
                             namelist[i]->d_name);
                }

                ch_data_ptr->id = channel_total;

                // get file size
                if ((fp = fopen(ch_data_ptr->input_file_name, "r")) == NULL) {
                    errMsg("opening input file");
                    ret = EXIT_FAILURE;
                    goto cleanup;
                }
                fseek(fp, 0L, SEEK_END);
                ch_data_ptr->input_file_size = ftell(fp);
                fclose(fp);
                if (file_size_compare == -1)
                    file_size_compare = ch_data_ptr->input_file_size;
                if (file_size_compare != ch_data_ptr->input_file_size) {
                    fprintf(stderr, "error: input files do not have the exact same size\n");
                    fprintf(stderr, " %s has %ld bytes, but %ld bytes were expected\n", ch_data_ptr->input_file_name,
                            ch_data_ptr->input_file_size, file_size_compare);
                    ret = EXIT_FAILURE;
                    goto cleanup;
                }
                list_add(channels, ch_data_ptr);
            }
        }
    }

    if (!channel_total) {
        fprintf(stderr, "error: no valid input channels found\n");
        show_usage();
        return EXIT_FAILURE;
    }

    ret = run_session(&sdi);

#ifdef CONFIG_DEBUG
    //ll_print(list_head(channels));
#endif

 cleanup:
    for (i = 0; i < ch_cnt; i++) {
        free(namelist[i]);
    }
    free(namelist);
    ch_data_ptr = list_head(channels);
    if (ch_data_ptr)
        ll_free_all(&ch_data_ptr);
    free(_input_dirname);
    free(_input_basename);

    return ret;
}
